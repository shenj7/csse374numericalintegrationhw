package part1;
import java.util.function.Function;

/**
 * Generated by MATLAB2Java
*/
public class Integrator {
	public static void integrate(Function<Double, Double> f, double lowerBound, double upperBound, double stepSize,
			String integrationMethod) {
		double returnValue = 0;
		for (double x_i = lowerBound; x_i < upperBound; x_i += stepSize) {
			returnValue += integrateOneStep(f, x_i, stepSize, integrationMethod);
		}
		
		System.out.printf("	%s returned: %.4f" + System.lineSeparator(), integrationMethod, returnValue);
	}

	private static double integrateOneStep(Function<Double, Double> f, double x_i, double stepSize,
			String integrationMethod) {
		
		if ("trapezoid".equals(integrationMethod)) {
			return trapezoidIntegration(f, x_i, stepSize);
		} else if ("simpson".equals(integrationMethod)) {
			return simpsonIntegration(f, x_i, stepSize);
		} else if ("3/8".equals(integrationMethod)) {
			return simpson38Integration(f, x_i, stepSize);
		} else if ("boole".equals(integrationMethod)) {
			return booleIntegration(f, x_i, stepSize);
		} else {
			throw new UnsupportedOperationException(integrationMethod);
		}
	}

	private static double trapezoidIntegration(Function<Double, Double> f, double x_i, double stepSize) {
		double f_0 = f.apply(x_i);
		double f_1 = f.apply(x_i + stepSize);

		return stepSize / 2.0 * (f_0 + f_1);
	}

	private static double simpsonIntegration(Function<Double, Double> f, double x_i, double stepSize) {
		stepSize = stepSize / 2;
		double f_0 = f.apply(x_i);
		double f_1 = f.apply(x_i + stepSize);
		double f_2 = f.apply(x_i + stepSize + stepSize);

		return stepSize / 3.0 * (f_0 + 4 * f_1 + f_2);
	}

	private static double simpson38Integration(Function<Double, Double> f, double x_i, double stepSize) {
		stepSize = stepSize / 3;
		double f_0 = f.apply(x_i);
		double f_1 = f.apply(x_i + stepSize);
		double f_2 = f.apply(x_i + stepSize + stepSize);
		double f_3 = f.apply(x_i + stepSize + stepSize + stepSize);

		return 3 * stepSize / 8.0 * (f_0 + 3 * f_1 + 3 * f_2 + f_3);
	}

	private static double booleIntegration(Function<Double, Double> f, double x_i, double stepSize) {
		stepSize = stepSize / 4;
		double f_0 = f.apply(x_i);
		double f_1 = f.apply(x_i + stepSize);
		double f_2 = f.apply(x_i + stepSize + stepSize);
		double f_3 = f.apply(x_i + stepSize + stepSize + stepSize);
		double f_4 = f.apply(x_i + stepSize + stepSize + stepSize + stepSize);

		return 2 * stepSize / 45.0 * (7 * f_0 + 32 * f_1 + 12 * f_2 + 32 * f_3 + 7 * f_4);
	}
}
